#version 450
layout (local_size_x = 32, local_size_y = 16) in;

// 输入：从Android Camera HardwareBuffer转换的采样器
layout (binding = 0) uniform sampler2D inputSampler;

// todo: 使用 pushConstants
// Letterbox参数（通过Uniform Buffer传递）
layout (binding = 1) uniform LetterboxParam {
    ivec2 unpaddingSize; // 输出图像不包含 padding 部分的长宽
    ivec2 padding;     // padding left/top
    vec4 fillColor;    // 填充颜色 rgba
} letterBoxParam;


// 输出1：128x128 RGBA8存储图像
layout (binding = 2, rgba8) uniform writeonly image2D letterBoxOutputImage;

void main() {
    // x: [0, 128)  y: [0, 128)
    ivec2 outputCoord = ivec2(gl_GlobalInvocationID.xy);

    // todo: 使用 pushConstants
    ivec2 letterBoxOutputSize = imageSize(letterBoxOutputImage);

    // 边界保护：跳过超出输出范围的线程
    if (any(greaterThanEqual(outputCoord, letterBoxOutputSize))) {
        return;
    }

    // 计算归一化UV（将输出坐标映射到[0,1]区间）
    // 考虑旋转
    vec2 letterBoxUv = vec2(
    1.0f - float(outputCoord.y - letterBoxParam.padding.y) / letterBoxParam.unpaddingSize.y,
    1.0f - float(outputCoord.x - letterBoxParam.padding.x) / letterBoxParam.unpaddingSize.x
    );
    //    vec2 uv = vec2(letterBoxParam.unpaddingSize.y - outputCoord.y, outputCoord.x) / vec2(letterBoxParam.unpaddingSize.y, letterBoxParam.unpaddingSize.x);

    // 判断是否在有效区域内（用step替代分支）
    vec2 inBounds = step(vec2(0.0), letterBoxUv) * step(letterBoxUv, vec2(1.0, 1.0));
    float isInside = inBounds.x * inBounds.y; // 仅当x/y均有效时为1

    // 采样输入图像（双线性滤波）
    vec4 color = texture(inputSampler, letterBoxUv);

    // 混合填充色与采样色（避免if分支）
    vec4 finalColor = mix(letterBoxParam.fillColor, color, isInside);

    // 写入输出图像
    imageStore(letterBoxOutputImage, outputCoord, finalColor);
}